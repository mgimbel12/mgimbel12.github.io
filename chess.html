<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mini Chess 5×5 — Capture the King</title>
<style>
  :root {
    --bg:#0e1325; --board:#1e2749; --light:#f0d9b5; --dark:#b58863;
    --white:#eaf2ff; --black:#0b0f1a; --accent:#5bc0be;
  }
  body { margin:0; background:var(--bg); color:#e6effa; font:16px/1.5 system-ui, sans-serif;
         display:grid; place-items:center; min-height:100vh; }
  .wrap { width:min(720px,92vw); padding:18px; }
  h1 { margin:0 0 6px; font-weight:800; letter-spacing:0.3px; }
  .status { margin:6px 0 12px; font-weight:700; }
  .board { width:min(92vw,480px); aspect-ratio:1/1; display:grid; grid-template-columns:repeat(5,1fr);
           border:10px solid #0a0f20; border-radius:14px; overflow:hidden; }
  .sq { position:relative; display:grid; place-items:center; font-weight:800; cursor:pointer; }
  .sq.light { background:var(--light); color:#1f243a; }
  .sq.dark  { background:var(--dark);  color:#101318; }
  .sq.sel { outline:3px solid var(--accent); outline-offset:-3px; }
  .sq.move::after { content:''; position:absolute; width:50%; height:50%;
                    border-radius:50%; background:rgba(91,192,190,0.35); }
  .piece { font-size:clamp(22px,6vmin,34px); line-height:1; user-select:none; }
  .w { color:#0b172e; text-shadow:0 1px 0 #fff8; }
  .b { color:#0d0e13; text-shadow:0 1px 0 #0008; filter:brightness(0.8); }
  .panel { display:flex; gap:10px; align-items:center; margin-top:12px; flex-wrap:wrap; }
  button { background:var(--accent); color:#061019; border:none; border-radius:10px; padding:0.6rem 0.9rem;
           font-weight:800; cursor:pointer; }
  .capt { margin-top:8px; font-size:14px; opacity:0.9; }
  .tag { display:inline-block; padding:2px 6px; border-radius:6px; background:#223; margin-right:6px; }
  .byline { margin-top:10px; font-size:13px; opacity:0.7; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Mini Chess 5×5</h1>
  <p class="status" id="status">White to move</p>

  <div class="board" id="board" aria-label="Mini Chess board"></div>

  <div class="panel">
    <button id="reset">Reset</button>
    <button id="swap">Swap sides</button>
  </div>

  <p class="capt" id="captured"></p>
  <p class="byline">Rules: capture the king to win. No check/checkmate; pawns move one forward, capture diagonally, promote to queen on last rank.</p>
</div>

<script>
  // 5x5 coordinates: (r,c) with r=0 (top, black home) to r=4 (bottom, white home)
  const boardEl = document.getElementById('board');
  const statusEl = document.getElementById('status');
  const capturedEl = document.getElementById('captured');
  const resetBtn = document.getElementById('reset');
  const swapBtn = document.getElementById('swap');

  // Pieces: wK,wQ,wR,wP / bK,bQ,bR,bP
  // Initial setup (top black, bottom white): R Q K Q R; pawns row in front.
  let start = [
    ['bR','bQ','bK','bQ','bR'],
    ['bP','bP','bP','bP','bP'],
    ['',   '',   '',   '',   '' ],
    ['wP','wP','wP','wP','wP'],
    ['wR','wQ','wK','wQ','wR']
  ];

  let board = JSON.parse(JSON.stringify(start));
  let whiteTurn = true;
  let over = false;
  let sel = null; // selected square [r,c]
  let moves = []; // legal moves for selected

  const glyph = {
    'K':'♔','Q':'♕','R':'♖','P':'♙',
  };

  function draw() {
    boardEl.innerHTML = '';
    for (let r = 0; r < 5; r++) {
      for (let c = 0; c < 5; c++) {
        const sq = document.createElement('button');
        sq.className = 'sq ' + (((r + c) % 2 === 0) ? 'light' : 'dark');
        sq.setAttribute('aria-label', `Square ${r},${c}`);
        const p = board[r][c];
        if (sel && sel[0] === r && sel[1] === c) sq.classList.add('sel');
        if (moves.find(m => m[0] === r && m[1] === c)) sq.classList.add('move');
        if (p) {
          const side = p[0] === 'w' ? 'w' : 'b';
          const type = p[1];
          const span = document.createElement('span');
          span.className = `piece ${side}`;
          span.textContent = (side === 'w')
            ? glyph[type]
            : ({'K':'♚','Q':'♛','R':'♜','P':'♟︎'})[type];
          sq.appendChild(span);
        }
        sq.onclick = () => onClick(r,c);
        boardEl.appendChild(sq);
      }
    }
  }

  function onClick(r,c) {
    if (over) return;
    const p = board[r][c];
    // If selecting your own piece, compute moves
    if (!sel) {
      if (!p) return;
      if (whiteTurn && p[0] !== 'w') return;
      if (!whiteTurn && p[0] !== 'b') return;
      sel = [r,c];
      moves = legalMoves(r,c,p);
      draw();
      return;
    }
    // If clicking a legal destination, move
    const isLegal = moves.some(m => m[0] === r && m[1] === c);
    if (isLegal) {
      const [sr, sc] = sel;
      const captured = board[r][c];
      board[r][c] = board[sr][sc];
      board[sr][sc] = '';
      // Promotion: pawns hitting last rank become queens
      const piece = board[r][c];
      if (piece[1] === 'P') {
        if (piece[0] === 'w' && r === 0) board[r][c] = 'wQ';
        if (piece[0] === 'b' && r === 4) board[r][c] = 'bQ';
      }
      if (captured) {
        addCaptured(captured);
        if (captured[1] === 'K') {
          over = true;
          statusEl.textContent = `${whiteTurn ? 'White' : 'Black'} wins (king captured)!`;
          sel = null; moves = []; draw();
          return;
        }
      }
      whiteTurn = !whiteTurn;
      statusEl.textContent = `${whiteTurn ? 'White' : 'Black'} to move`;
      sel = null; moves = []; draw();
      return;
    }
    // Else, reselect if clicking your piece; otherwise clear selection
    if (p && ((whiteTurn && p[0] === 'w') || (!whiteTurn && p[0] === 'b'))) {
      sel = [r,c];
      moves = legalMoves(r,c,p);
    } else {
      sel = null; moves = [];
    }
    draw();
  }

  function addCaptured(p) {
    const tag = document.createElement('span');
    tag.className = 'tag';
    const side = p[0] === 'w' ? 'White' : 'Black';
    const name = ({K:'King',Q:'Queen',R:'Rook',P:'Pawn'})[p[1]];
    tag.textContent = `${side} ${name} ×`;
    capturedEl.appendChild(tag);
  }

  function legalMoves(r,c,p) {
    const side = p[0];
    const type = p[1];
    const dir = side === 'w' ? -1 : 1; // forward direction
    let out = [];

    function pushIf(r2,c2) {
      if (r2 < 0 || r2 > 4 || c2 < 0 || c2 > 4) return;
      const t = board[r2][c2];
      if (!t) out.push([r2,c2]);
      else if (t[0] !== side) out.push([r2,c2]); // captures allowed
    }

    function rays(drs) {
      for (const [dr,dc] of drs) {
        let rr = r + dr, cc = c + dc;
        while (rr >= 0 && rr <= 4 && cc >= 0 && cc <= 4) {
          const t = board[rr][cc];
          if (!t) out.push([rr,cc]);
          else {
            if (t[0] !== side) out.push([rr,cc]);
            break;
          }
          rr += dr; cc += dc;
        }
      }
    }

    if (type === 'K') {
      const steps = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
      for (const [dr,dc] of steps) pushIf(r+dr, c+dc);
    }
    if (type === 'Q') {
      rays([[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]);
    }
    if (type === 'R') {
      rays([[1,0],[-1,0],[0,1],[0,-1]]);
    }
    if (type === 'P') {
      // Forward move (no two-step)
      const f = [r+dir, c];
      if (f[0] >= 0 && f[0] <= 4 && !board[f[0]][f[1]]) out.push(f);
      // Diagonal captures
      for (const dc of [-1,1]) {
        const rr = r + dir, cc = c + dc;
        if (rr >= 0 && rr <= 4 && cc >= 0 && cc <= 4) {
          const t = board[rr][cc];
          if (t && t[0] !== side) out.push([rr,cc]);
        }
      }
    }
    return out;
  }

  function reset() {
    board = JSON.parse(JSON.stringify(start));
    whiteTurn = true; over = false; sel = null; moves = [];
    statusEl.textContent = 'White to move';
    capturedEl.textContent = '';
    draw();
  }

  function swapSides() {
    // Flip board and swap colors
    const flipped = [];
    for (let r = 0; r < 5; r++) {
      flipped.push([...board[4 - r]].reverse());
    }
    board = flipped.map(row => row.map(p => {
      if (!p) return '';
      return (p[0] === 'w' ? 'b' : 'w') + p[1];
    }));
    whiteTurn = true; over = false; sel = null; moves = [];
    statusEl.textContent = 'White to move';
    capturedEl.textContent = '';
    draw();
  }

  resetBtn.onclick = reset;
  swapBtn.onclick = swapSides;

  draw();
</script>
</body>
</html>
